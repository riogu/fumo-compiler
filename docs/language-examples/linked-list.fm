struct Node;
fn malloc(size: i64) -> any*;
fn free(ptr: any*) -> void;
fn printf(format: const char*, ...) -> i32;

struct Node {
    let value: any*;
    let next: Node*;
    
    fn static new(val: any*) -> Node* {
        let node: Node* = malloc(16); // sizeof(any*) + sizeof(Node*)
        node->value = val;
        node->next = null;
        return node;
    }
}

struct List {
    let head: Node*;
    let size: i32;
    
    fn static new() -> List {
        return List {null, 0}; 
    }
    
    fn push_front(value: any*) -> void {
        let new_node: Node* = Node::new(value);
        new_node->next = head;
        head = new_node;
        size = size + 1;
    }
    
    fn pop_front() -> any* {
        if !head {
            return null; // Return null on empty list
        }
        
        let value: any* = head->value;
        let old_head: Node* = head;
        head = head->next;
        free(old_head);
        size = size - 1;
        return value;
    }
    
    fn print_as_ints() -> void {
        // Helper to print assuming all values are i32*
        printf("[");
        let current: Node* = head;
        let first: bool = true;
        
        while current {
            if !first {
                printf(", ");
            }
            if current->value {
                let int_ptr: i32* = current->value;
                printf("%d", *int_ptr);
            } else {
                printf("null");
            }
            current = current->next;
            first = false;
        }
        printf("]\n");
    }
    
    fn print_as_strings() -> void {
        // Helper to print assuming all values are char*
        printf("[");
        let current: Node* = head;
        let first: bool = true;
        
        while current {
            if !first {
                printf(", ");
            }
            if current->value {
                let str_ptr: char* = current->value;
                printf("\"%s\"", str_ptr);
            } else {
                printf("null");
            }
            current = current->next;
            first = false;
        }
        printf("]\n");
    }
    
    fn length() -> i32 {
        return size;
    }
    
    fn find(value: any*) -> bool {
        // This compares pointers, not values
        let current: Node* = head;
        while current {
            if current->value == value {
                return true;
            }
            current = current->next;
        }
        return false;
    }
    
    fn clear() -> void {
        while head {
            let temp: Node* = head;
            head = head->next;
            free(temp);
        }
        size = 0;
    }
}

fn main() -> i32 {
    let list = List::new();
    
    // Create some data to store
    let val1: i32 = 10;
    let val2: i32 = 20;
    let val3: i32 = 30;
    let val4: i32 = 40;
    
    printf("Adding integer pointers to list...\n");
    list.push_front(&val1);
    list.push_front(&val2);
    list.push_front(&val3);
    list.push_front(&val4);
    
    printf("List contents (as ints): ");
    list.print_as_ints();
    printf("List size: %d\n", list.length());
    
    // Finding by pointer value
    if list.find(&val2) {
        printf("Looking for val2 pointer: found\n");
    } else {
        printf("Looking for val2 pointer: not found\n");
    }
    
    printf("Popping elements:\n");
    while list.length() > 0 {
        let value: any* = list.pop_front();
        if value {
            let int_val: i32* = value;
            printf("Popped: %d, remaining: ", *int_val);
        } else {
            printf("Popped: null, remaining: ");
        }
        list.print_as_ints();
    }
    
    // Now try with strings
    printf("\nTesting with strings:\n");
    let str1: char* = "hello";
    let str2: char* = "world";
    let str3: char* = "test";
    
    list.push_front(str1);
    list.push_front(str2);
    list.push_front(str3);
    
    printf("String list contents: ");
    list.print_as_strings();
    
    list.clear();
    return 0;
}
