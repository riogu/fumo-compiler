struct Node[T] {
    let data: T;
    let next: Node[T]*; // is not generic type name, "Node[{}]" is solvable
    
    fn get_data() -> T {
        return data;
    }
    
    fn set_next(next_node: Node[T]*) -> void {
        next = next_node;
    }
    
    fn static make(value: T) -> Node[T] {
        return Node[T]{value, null};
    }
}

// solve every identifier, unless they are a generic_type_name
fn create_chain[T](first: T, second: T) -> T {
    let head = Node[T]::make(first); // no typechecking
    let tail = Node[Foo]::make(second); // no typechecking

    let int_no = Node[i32]{23}; // no typechecking?
    let int_no = Foo[i32, T]{23}; // this is partially generic,what to do?

    let int_node = Node[i32]::make(42); // no typechecking?

    int_node = head; // what now?
    head.set_next(&int_node); // and now?
    head.set_next(&tail);
    return head;
}

fn main() -> i32 {
    let int_node = Node[i32]::make(42);
    let float_node = Node[f64]::make(3.14);
    
    let chain = create_chain[i32](1, 2);
    
    return 0;
}
